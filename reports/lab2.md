# Lab4

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   > *《你交流的对象说明》*
   >
   > 无交流

2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   > *《你参考的资料说明》*
   >
   > 除实验文档外无其他资料

\3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

\4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

## 编程作业

`pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize` 

- 按照之前的方法计算出正确的时间
- 但是由于_ts是一个指向应用地址空间的指针，而现在syscall是系统调用，它只能修改内核地址空间的内容，因此需要用到`translated_byte_buffer` ：尝试将**按应用的虚地址**指向的缓冲区转换为一组**按内核虚地址**指向的字节数组切片构成的向量，然后修改_ts对应的物理地址的内容
- 这个缓冲区的应用虚拟地址肯定是连续的，但是内核虚拟地址可能是不连续的

`pub fn sys_task_info(_ti: *mut TaskInfo) -> isize` 

- 由于_ti也是一个指向应用地址空间的指针，因此也是一样的思路，将其转换成一片可修改的物理内存的区域
- 也要注意分页的问题，即内核虚拟地址可能不是连续的，按字节填充buffer

`fn sys_mmap(start: usize, len: usize, port: usize) -> isize`

- 这个主要是要检查[start, start + len) 中是否存在已经被映射的页
- 你增加 PTE_U 了吗？是的，要手动添加这个标志位，表示U模式有效
- 然后直接使用task control block的mem_set的接口

`pub fn sys_munmap(_start: usize, _len: usize) -> isize` 

- 主要是要检查[start, start + len) 中是否存在未被映射的虚存
    - 略麻烦，需要手动查找任务地址空间的页表，看看页表里面vpn对应的那一个页表项的标志位是否有效
- unmap操作也简单，直接调用页表的接口unmap，但一定要修改task control block的地址空间里面的areas，去掉已经unmap的逻辑段